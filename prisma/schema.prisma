// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

//sources for models: https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#default
//https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#type-modifiers

//data models/Prisma models-> defines your application models
//model name must start with a letter and spelled in PascalCase (you can use @map to match db model/fields names)
//Map to the tables/collections
//Form the foundation of the queries used with generated Prisma Client API
//Prisma Client provides generated type definitions for your models and any variations of them to make database access entirely type safe.
//
//field Name -> must start with letter & spelled in camelCase
//field Type ->can be scalar type(includes enums) or model type(field is then = relation field)
//model must have at least one unique field marked with either: @unique, @@unique, @id, or @@id
//Attributes ->Attributes (including native database type attributes - type attributes) modify the behavior of fields or model blocks. eg @default('hello')
//type attributes describe the underlying database type & are specific to that db eg @db.ObjectId -> see docs: 'Prisma schema reference'
//Attribute functions represent default values auto generated by the database. Used inside eg @default(autoincrement())
//type modifiers: modify field type, They are 2: []  Makes a field a list, ?  Make a field optional//can't combine both(optional lists not supported)

//embedded docs in mongodb is supported with 'Composite types' eg field as an object//only when using mongodb//use json for other dbs
model User {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  //id                          String    @id @default(uuid()) 
  //@id field is not optional(either pass value or add @default) and cannot be defined on a relation field. A model can only have one field marked with @id. id fields are unique. In mongoDb, every model must define @id field(or  @db.ObjectId) & mapped with @map("_id")
  // id    Int @id @default(autoincrement()) //if you want an auto incremented number
  //id   String  @db.ObjectId  @map("_id") @default(auto()) //if using mongoDb (To use an ObjectId as your model id, @db.ObjectId type attribute is mandatory. @default(auto()) generates a default ObjectId if none is passed)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  email       String   @unique //@map("user_email")//you can map email to user_email field in db
  username    String // @db.VarChar(255)->to set length-see suported Native type attributes per db
  password    String
  phoneNumber String?
  roles       Role[]   @default([BUYER]) //enum //supported natively in pg/mysql but enforced at Prisma level in MongoDB
  //newEmail                    String?
  //isVerified                  Boolean   @default(false)
  // verifyEmailToken            String?   @unique
  //resetPasswordToken          String?   @unique
  //for numbers, use Int for a number less than 2147483647( date.now() is bigger, use DateTime)
  //Don't use BigInt for large numbers, else res.json(resultsWithBigInitField) will throw "Do not know how to serialize a BigInt" error
  //This is 'cause JSON.stringify() can't serialize the BigInit field value, BigInit is not a number
  //use a string(then parseInt(string) when needed) or if it's date use DateTime
  // resetPasswordTokenExpiresAt DateTime? //BigInt? // Int = int4= 32-bit interger(max value= 2147483647), BigInt= int8, 64 bit interger(max value = 9223372036854775807)//use BigInt to support large numbers else error while saving "unable to fit integer value into an int4"
  //relation is a connection between two models in the Prisma schema.
  //At a Prisma level, a connection between two models is always represented by a relation field on each side of the relation.
  //1.One-to-one relations(1-1)-> relations where at most one record can be connected on both sides of the relation.  //user can only have one profile and vice versa
  //the inverse side that doesn't store the foreign key
  //profile   Profile? //Relation field-> define connections between models at the Prisma level and do not exist in the database. They are relation fields since their types are not scalar types but model types
  //user can have zero profiles or one profile
  //this side without relation scalar field must be optional

  cart Cart?

  //2. One-to-many (1-n) relations -> where one record on one side of the relation can be connected to zero or more records on the other side.
  //a user can have zero or more notes (altho there is no ?, notes field is optional)
  //notes   Note[] //does not exist in db// This list side of a 1-n relation is always mandatory(no '?').
  reviews Review[]

  orders Order[]

  products Product[]

  //@@map("users") //you can map 'User' model to users table in db (i.e if different)//not needed
}

// model Profile {
//   id             String   @id @default(auto()) @map("_id") @db.ObjectId
//   createdAt      DateTime @default(now()) //default value can be @default('hello' | 3 | ["2", 4], funtion() )
//   updatedAt      DateTime @updatedAt
//   city           String?
//   region         String?
//   additionalInfo String?
//   address        String? //@db.VarChar(255)//not supported by mongo //max 255 characters //varchar is 8-bit(bit = 0 or 1) binary number //255 is the maximum value of a 8 bit integer : 11111111 = 255 (2^8 - 1, We subtract one because numbers in computers begin from 0)
//   phoneNumbers   String[]
//   profilePic     Image?
//   //1. Inverse side-> One-to-One relation(1-1)->side that is storing the foreign key
//   user           User?    @relation(fields: [userId], references: [id], onDelete: Cascade) //annotated relation field( as it has @relation attribute. Doesn't exist in db)
//   userId         String?  @unique @db.ObjectId // relation scalar field (must be referenced inside `@relation` attribute above. Field type must match type of referenced field type) //it is the foreign key that connects Profile and User & exists in db. Referenced field(can be any field) must be @unique or be a model Id to guarantee that there is only a single User connected to each Profile.
//   //A scalar field becomes a relation scalar field when it's used in the fields of a @relation attribute
//   //The @unique constraint/attribute makes this relation 1-1. If this UNIQUE constraint was missing, the relation would be considered a 1-n relation(and you would get error if inverse side is not a list ).
//   //this side with a relation scalar field can be optional or mandatory(add or remove ? type modifier to both scalar and relation fields)
//   //in mongoDb use:  userId String @unique @db.ObjectId since referenced User Model Id is an ObjectId
//   //For MongoDB, Prisma currently uses a normalized data model design, which means that documents reference each other by ID in a similar way to relational databases

//   //#Referential actions 
//   //Referential actions determine what happens to a record when your application deletes or updates a related record. 
//   //Referential actions are features of foreign key constraints that exist to preserve referential integrity in your database.
//   //If you do not specify a referential action, Prisma falls back to a default:
//   //1. Optional relations: onDelete: SetNull, onUpdate: Cascade
//   //2. Mandatory relations: onDelete: Restrict, onUpdate: Cascade
//   //note, you can't use setNull for mandatory relation fields
//   //adding onDelete: Cascade inside @relation() means that deleting the User record will also delete all related Profile record(s).
//   //Supported referential actions:
//   //1. Cascade = onDelete->Deleting a referenced record will trigger the deletion of referencing record, onUpdate-> Updates the relation scalar fields if the referenced scalar fields of the dependent record are updated eg if user is deleted, delete profile(s), if user Id changes, update userId
//   //2. Restrict = onDelete->  Prevents the deletion if any referencing records exist, onUpdate->  Prevents the identifier of a referenced record from being changed.eg Users with profiles cannot be deleted, User's id cannot be changed
//   //3. NoAction = similar to Restrict but difference between the two is dependent on the database eg in mongoDB, When a record is modified or deleted, nothing is done to any related records
//   //4. SetNull = onDelete->  The scalar field of the referencing object will be set to NULL , onUpdate->When updating the identifier of a referenced object, the scalar fields of the referencing objects will be set to NULL. SetNull will only work on optional relations else runtime error since the scalar fields cannot be null eg When deleting a User, the userId will be set to NULL for all its profiles. When changing a User's id, the userId will be set to NULL for all its profiles.
//   //5. SetDefault= onDelete->  The scalar field of the referencing object will be set to the fields default value. , onUpdate->The scalar field of the referencing object will be set to the fields default value defined inside @default(value).
// }

model Product {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  title       String
  description String

  images          Image[] //composite type   
  price           Int
  discountedPrice Int
  quantity        Int
  sold            Int?
  styles          String[] @default([])
  sizes           String[] @default([])
  tags            String[] @default([])
  colors          String[] @default([])
  locations       String[] @default([])
  brand           String
  rating          Int      @default(0)
  totalReviews    Int      @default(0)

  reviews Review[]

  category Category?
  //brand   Brand  @relation(fields: [brandId], references: [id], onDelete: Cascade)
  // brandId String @db.ObjectId

  //category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  //categoryId String   @db.ObjectId
  Cart   Cart?   @relation(fields: [cartId], references: [id])
  cartId String? @db.ObjectId

  order   Order?  @relation(fields: [orderId], references: [id])
  orderId String? @db.ObjectId

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade) //annotated relation field( as it has @relation attribute. Doesn't exist in db)
  userId String @db.ObjectId
}

//brands
// model Brand {
//   id          String    @id @default(auto()) @map("_id") @db.ObjectId
//   createdAt   DateTime  @default(now())
//   updatedAt   DateTime  @updatedAt
//   name        String    @unique
//   images      Image[] //composite type
//   owner       String
//   description String
//   products    Product[]
// }

// ///eg  CAT
type Category {
  // id          String    @id @default(auto()) @map("_id") @db.ObjectId
  // createdAt   DateTime  @default(now())
  //updatedAt   DateTime  @updatedAt
  cat    String
  subCat String
  //description String
  //products    Product[]
}

model Review {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String  @db.ObjectId

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade) //annotated relation field( as it has @relation attribute. Doesn't exist in db)
  userId String @db.ObjectId

  comment String
  rating  Int
}

model Coupon {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  code      String
  expiry    DateTime
  discount  Int
}

model Cart {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  products Product[]

  quantity Quantity

  subTotal Int

  cartBy   User   @relation(fields: [cartById], references: [id], onDelete: Cascade) //annotated relation field( as it has @relation attribute. Doesn't exist in db)
  cartById String @unique @db.ObjectId
}

type Quantity {
  id  String
  qty Int
}

model Order {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items   Item[]
  address ShippingAddress

  orderStatus OrderStatus @default(PROCESSING)

  paymentInfo PaymentDetails?

  subTotal Int
  shipping Int
  discount Int? //this optional else the usual missing field error:  "Arg 'discount' is missing" if undefined or not passed in data at all
  total    Int //subtotal + shipping(-minus coupon discount)

  //relations 1-n inverse side
  products  Product[]
  //1-n//user can have many orders//1-1 means user id can only exist in only one doc in whole order collection//single instance of user instance
  orderBy   User      @relation(fields: [orderById], references: [id], onDelete: Cascade) //annotated relation field( as it has @relation attribute. Doesn't exist in db)
  orderById String    @db.ObjectId
}

type Item {
  id       String
  units    Int
  color    String
  style    String
  size     String
  location String
}

type ShippingAddress {
  phoneNumbers   String[]
  firstName      String
  lastName       String
  region         String
  city           String
  address        String
  additionalInfo String?
}

type PaymentDetails {
  method     PaymentMethod
  receivedAt DateTime
  status     PaymentStatus
}

enum PaymentMethod {
  CARD
  MPESA
  ONDELIVERY
}

enum OrderStatus {
  PROCESSING
  CONFIRMED
  DISPATCHED
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentStatus {
  PAID
  PENDING
}

type Image {
  publicId String
  url      String
}

//enums must start with a letter & use the singular form
enum Role {
  BUYER
  VENDOR
  ADMIN
}
